### B+索引和哈希索引
B+索引底层是B+树。它是一个平衡的多叉树，所有关键字都在叶子结点出现；所有叶子结点使用双向链表组织起来，且是有序的，所以适合范围查找。由于B+树查询只会在叶子结点被命中，所以查询时间是比较平稳的，平均查询复杂度O(logN)，N为B+树的高度。（矮胖子)

哈希索引底层是一个哈希表，查询时使用特定的hash函数映射到不同bucket里。

特点：做等值查询时，有绝对的优势，O(1)时间复杂度。哈希索引不支持范围查找、排序、模糊查询、联合索引中最左匹配原则，但B+树都支持。

* 为什么不能是红黑树或B树？
红黑树是一种二叉平衡树，n个节点，高度为logn，所以高度相比B+N叉树高很多，所以查询效率不及B+树。

B树也是一种多叉平衡树，与B+树不同的是，查询关键字分布在整颗树中，B+树只在叶子结点。B+树非叶子结点存的都是索引，没有data域指针，所以内部结点更小，那么相同一个磁盘块，B+树能容纳更多的索引结点，所以B+树磁盘IO更少。

### 隔离级别
* 串行化(Serializable)
最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。

* 可重复读(Repetable Read)
InnoDB默认使用RR事务隔离级别。它保证了同一事务执行时，不同时间点看到的数据总是相同的。可避免脏读、不可重复读的发生，但也会发生幻读。

* 读已提交(Read Committed)
只能看到事务已经提交事务所做的改变，因此可以避免脏读。但在该事务执行期间，可能有其他事务有新的commit，所以可能出现幻读。

* 读未提交(Read Uncommitted)
最低隔离级别。所有事务都可以看到其他未提交事务的结果，可能发生脏读。

一些名词解释：
* 脏读
事务A已修改某条数据，此时事务B读取了事务A更改的数据，但事务A由于某种原因回滚了，此时事务B读到的数据和数据库回滚的数据不同，称事务B读到脏数据。（读取未提交的事务的数据）

* 不可重复读
事务A读取了某条数据，在未提交时，事务B修改了该条数据，此时事务A再次读取这条数据，两次读取的数据不同。（两次读同一个记录，但结果不同）

* 幻读
事务A按一定条件读取了表中一些数据，事务B向该表插入了一些满足事务A查询条件的数据，最后，事务A再次以相同条件查询时，发现多出一些数据。（一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。）（同一个条件的两次查询，得到的记录数不同）

### MVCC
MVCC，Multivesion concurrency control（多版本并发控制）。
它是通过保存数据在某个时间节点的快照来实现的。所以，每个事务不管执行多长时间，看到的数据是一致的。
当然可能发生同一张表，同一时刻，不同事务看到的数据不一样。

MVCC通过每行（每条记录）维护两个隐藏列实现，分别保存了数据行版本号和删除行版本号。每开启一个新事务，事务版本号会自动递增。
* 插入数据时，数据行版本为当前事务ID号；删除版本号为NULL；
* 删除数据时，修改被删除行的删除版本号为当前事务ID号；
* 修改数据时，拷贝一份，并设置数据行版本为当前事务ID，删除版本号为NULL；
* 查询数据时，只输出数据行版本小于等于当前事务ID的数据行，且数据行的删除版本号为NULL或大于当前事务ID
  * 前者确保读取的行，在事务开始前一直存在；后者确保读出的记录是在事务之后删除的。

* 优势
读不加锁，读写不冲突，极大提高了mysql的并发性。

说明：在RU（读未提交）和串形隔离级别下，不会使用MVCC。
MVCC是在并发条件下，维护多个版本数据的方法。但RU隔离级别，每次都是获取到最新的值；串形隔离，每次读也会加读锁，有数据更新也是阻塞，也不存在多个版本情况。

RR（可重复读）隔离等级下，使用MVCC可以解决幻读问题。使用MVCC看到的数据是在开始执行事务的那一刻数据状态。

### 当前读与快照读
* 快照读
基于MVCC和undo log来实现的，适用于简单select语句。

* 当前读
基于行锁 + GAP锁来实现的，适用于 insert，update，delete， select ... for update（写锁）， select ... lock in share mode（共享锁）语句。

### ACID
事务的四大特性原子性、一致性、隔离性、持久性。

原子性（Atomicity）：要么都做，要么都不做。

隔离性（Isolation）：多个并发事务之间，互不干扰。（或者说事务处理过程的中间结果对外不可见）

持久性（Durability）：事务一旦提交，数据库更改是永久性的。（写入磁盘）

一致性（Consistency）：事务执行前后，数据总是处于一种合法的状态，满足我们设定的约束。

* 如何保障一致性
ACID四大特性之中，一致性是目的，原子性、隔离性、持久性是手段，是为了保证一致性。

* 如何保障原子性
innodb中利用undo log，即回滚日志。undo log记录了回滚所需的信息，当事务执行失败或调用了rollback，可以利用undo log回滚到之前的状态。

* 如何保障持久性
innodb利用redo log。事务可能涉及多个数据页修改，他们可能不相邻，属于随机IO，速度比较慢。
redo log是在事务提交前，将这些更改写入磁盘，属于文件追加，顺序IO，效率相对较高。

* 如何保障隔离性
利用锁和MVCC机制。

一些基础概念：
* redo log
由内存中的重做日志缓冲和重做日志文件组成。
每次数据更新时，会先更新重做日志缓冲，然后根据innodb_flush_log_at_trx_commit控制缓冲写入redo log的时机
  - 0，事务提交时，每秒触发一次redo buffer写入磁盘，并调用fsync刷新IO缓存；(每秒写入)
  - 1，事务提交时，立即将redo buffer写入日志文件，并调用fsync刷新IO缓存；（立即写入）
  - 2，事务提交时，立即将redo buffer写入page cache，InnoDB后台线程每秒做一次IO刷新操作。

* undo log
redo log记录了事务操作的变化，但事务回滚需要undo log。

* bin log
二进制日志记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句），但是不包括 select 和 show 这类操作。Binlog 有以下几个作用：
  - 恢复：数据恢复时可以使用二进制日志
  - 复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步
  - 审计：可以通过二进制日志进行审计数据的变更操作

通过参数sync_binlog来控制累积多少个事务后才将二进制日志 fsync 到磁盘。
  - sync_binlog=0，表示每次提交事务都只write，不fsync。
  - sync_binlog=1，表示每次提交事务都会执行fsync。
  - sync_binlog=N(N>1)，表示每次提交事务都write，累积N个事务后才fsync。

### InnoDB和MyISAM存储引擎
Mysql 5.5之前默认的存储引擎是MyISAM，5.5之后改为InnoDB。InnoDB后来居上的主要原因是，
* InnoDB支持事务，适合并发条件下要求数据一致性场景。
* InnoDB支持行锁，有效降低由于删除和更新导致的锁定。（更细粒度的锁，并发性更好，消耗也大）

MyISAM崩溃后不能安全的恢复。（不支持事务可能导致数据不一致性）
* InnoDB支持MVCC，MyISAM不支持；
* InnoDB支持外键，MyISAM不支持；
* InnoDB不支持全文索引，但MyISAM支持。

底层，MyISAM B+索引的叶子节点value域存放数据记录的地址，InnoDB B+索引存放的是完整的数据行。

innodb数据存储形式：数据表分为.frm和.idb两个文件，.frm存储表结构，.idb存储数据行和索引。

innodb表基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。非主键索引必须包含主键列，最后回表查询

myisam数据存储形式：索引和数据分离，.frm存储表结构，.myd存储表数据，.myi存储索引。

myisam不支持行锁，所以读取时加共享锁，写入时加入排他锁。
由于是对整张表加锁，相比innodb，在并发写时效率低。innodb使用MVCC实现读写不加锁，为事务创建数据快照，保证并发读写不冲突。

### 聚集索引与普通索引
> 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
> 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

InnoDB存储引擎将索引分为聚集索引和辅助索引（非聚集索引）两大类。

聚集索引的逻辑顺序和物理存储顺序一致的，逻辑相邻则物理上也相邻。这个逻辑顺序是基于主键构建的B+树索引。
聚集索引带来的好处是：基于主键作范围查询，速度非常快。
因为Innodb中B+树叶子节点存储索引和数据行，基于主键逻辑相邻的数据都在同一个磁盘块中，或相邻的磁盘块中，不需要作随机IO的读操作，更加高效。

聚集索引的缺点，
* 插入速度严重依赖插入顺序，如果是按照主键顺序插入是加载数据到Innodb表中速度最快的。
* 更新聚集索引列代价很高，因为会强制Innodb将每个被更新的行移动到新的位置。
* 基于聚集索引的表插入新行时，可能导致页分裂问题。当插入行一定要插入某个已满的页中时，存储引擎会将这个页分裂为两个页，来容纳该数据行。
* 基于二级索引（辅助索引）的查询，可能导致回表，经过两次索引查找。

Innodb的辅助索引B+树的叶子节点对应存储辅助索引key和主键key，所以需要一次回表查询聚集索引，才能得到完整的数据行。
相比，MyISAM的数据行和索引分来存储，索引的value域存储数据行的物理偏移地址，所以还需要一次磁盘IO读操作。

### 主键索引、普通索引和唯一索引
按照表列属性分类，索引分为普通索引（非主键，非唯一列索引），主键索引和唯一索引（索引列值必须唯一，可以包含NULL）。

普通索引可以写入重复值，唯一索引不可写入重复值。
数据修改时，普通索引可以使用change buffer，而唯一索引不行。
* Innodb使用change buffer对insert，delete和update进行缓存，提高磁盘IO的效率（减少随机取写，可能能合并读写操作）；
* 唯一索引必须将数据读入内存，才能判断是否违反唯一性约束，所以没必要进行缓存。

基于普通索引查询时，满足查询条件，还会继续查询下一条记录，直到不满足为止；而唯一索引则查到一条记录直接返回；

### 联合索引
联合索引中键的个数大于1，与单个键的B+树一样，都是按键排序的。
如a和b组成的联合索引，可能是(1，1)，(1，2)，(1，3)，(2，1)，(2，2)等等。它们首先按照a有序，在a相同时，保持b有序。
联合索引带来的好处是，
* a和b两个字段作条件查询时，可以使用索引，速度快；
* 单独基于a字段的条件查询也是可以走索引的，但是单独的b字段查询走不了索引（联合索引的最左原则）

使用联合索引时，应注意，
* 把区分度最大的列放在联合索引最左边
* 经常作查询条件的列，放入联合索引中

### 覆盖索引
覆盖索引是指从辅助索引中就可以组装出查询的结果，不需要根据主键key再次回表拿到完整的数据行。
优点：不需要再次扫描聚集索引，可以减少SQL操作磁盘IO次数。

### 全局锁
当使用全局锁后，所有表变为只读状态，当前会话的更新操作将报错，其他会话更新操作都将阻塞。
全局锁一般用于库备份，备份过程中库是只读的。如果是主库备份，导致业务不能写入修改数据，如果是从库，会加大主从延迟。
```sql
flush tables with read lock -- 全局读锁
unlock tables --解锁
```

### 表级锁
表级锁分为表锁和元数据锁MDL。
表锁有读写锁，读锁又称为共享S锁，写锁又称为排它X锁。
* 执行表读锁后，本会话和其他会话都能读，但本会话写会报错，其他会话写操作将阻塞。
* 执行表写锁后，本会话可以读写，其他会话都被阻塞。
```sql
lock tables table_name read -- 表读锁
lock tables table_name write -- 表写锁
lock tables t1 read, t2 read, t3 write -- 为多个表加锁
```
加表锁后，用户进入独立的环境，只能访问table_name的数据，直到unlock tables。

使用表锁，而不是行锁场景：
* 事务需要更新某张表中大部分或全部数据。如果使用行锁，事务执行效率很低，导致其他事务长时间锁等待。
* 事务涉及多个表，逻辑比较复杂，可能导致死锁，导致大量的事务回滚。

元数据锁（metadata lock， MDL锁）
MDL锁是为了解决同一张表DML（data manipulation language）和DDL（data defination language）并发执行导致的数据不一致问题。
当一个事务对表作查询时，会获取MDL_SHARED_READ的MDL锁，此时另一个事务执行DDL，则需要MDL_EXCLUSIVE锁，是排他锁，会获取不成功。
当一个事务对表作更新时，会获取MDL_SHARED_WRITE的MDL锁。

### 行锁
Innodb行锁也分为共享锁和排它锁。
* 共享锁：允许一个事务去读一行，阻止其他事务获得相同数据行的排它锁；
* 排它锁：允许获得排它锁更新数据行，阻止其他事务获取相同数据行的共享锁和排它锁。

对于普通select语句，不会使用行锁，而是使用快照读MVCC的方法。
当需要使用当前读，则需要手动加锁，
```sql
select * from table_name where condition lock in share mode -- 共享锁
select * from table_name where condition for update -- 排他锁
```

按照行锁加锁位置分类，行锁有可分为：记录锁（record lock），间隙锁（gap lock）和next-key lock。
记录锁对单个记录上锁；
间隙锁是对索引间的间隙加锁，但不包含记录本身；
next-key lock是锁定一个范围，包括记录和间隙。

### 锁与索引的联系
读已提交RC隔离级别下，InnoDB不使用间隙锁，但会使用行锁。
* 没有索引时，InnoDB当前读会对所有记录加排它锁，可能导致大量锁冲突；
* 若使用唯一索引，则会在满足条件的数据行加排它锁(单条），并在相应的聚集索引加排它锁；
* 若使用非唯一索引，则会在所有满足条件的数据行加排它锁，聚集索引也加排它锁；

可重复读RR隔离级别下，InnoDB使用间隙锁和行锁。
* 没有使用索引时，则每条记录加排它锁，每个间隙加间隙锁；（为了性能，条件字段最好有索引）
* 若使用唯一索引，则不使用间隙锁，因为查询结果是单条记录，它只会在唯一索引和聚集索引上加排它锁；
* 若使用非唯一索引，则在所有满足条件的记录上排它锁及间隙锁，聚集索引也加排它锁；

间隙锁保证在满足条件的索引间插入数据行时，处于阻塞。所以RR隔离级别，行锁+间隙锁可以解决幻读问题。
设置隔离级别的方法：
```sql
set session transaction_isolation = 'REPRETABLE-READ' -- 设置RR隔离级别
```

### 死锁
死锁是指两个及以上的事务相互占有对方的资源，导致彼此都不能正常执行。
Innodb处理死锁有两种方式，
* 检测到锁的循环依赖，立即返回错误。（需要将innodb_deadlock_detect设置为on）
* 等查询时间达到锁等待超时时间，立即放弃锁请求。默认为50s。
死锁常常是因为加锁顺序不一致导致的，或者重复获取同一个排它锁

降低死锁的方法，
* SQL语句的条件尽量使用索引（不使用索引时，每条记录都排它锁和间隙锁）
* 基于主键或唯一索引来更新数据（唯一索引不加间隙锁）
* 减少范围更新，尤其是基于非主键，非唯一索引的
* 事务加锁顺序要一致，尽可能一次性锁定的
* 将RR隔离级别下调至RC隔离级别(不使用间隙锁)

